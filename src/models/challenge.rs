use serde::{Deserialize, Serialize};
use std::path::PathBuf;

/// Severity level of a challenge issue
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum IssueSeverity {
    Low,
    Medium,
    High,
}

impl IssueSeverity {
    pub fn emoji(&self) -> &'static str {
        match self {
            IssueSeverity::Low => "ðŸŸ¢",
            IssueSeverity::Medium => "ðŸŸ¡",
            IssueSeverity::High => "ðŸ”´",
        }
    }

    pub fn name(&self) -> &'static str {
        match self {
            IssueSeverity::Low => "Low",
            IssueSeverity::Medium => "Medium",
            IssueSeverity::High => "High",
        }
    }
}

/// Represents an issue found during challenge
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChallengeIssue {
    /// Issue title
    pub title: String,

    /// Severity level
    pub severity: IssueSeverity,

    /// Location in proposal (e.g., "proposal.md:15" or "tasks.md:1.2")
    pub location: String,

    /// Description of the issue
    pub description: String,

    /// Suggested fix
    pub suggestion: String,

    /// Line number in CHALLENGE.md (for reference)
    pub line_number: Option<usize>,
}

impl ChallengeIssue {
    pub fn new(
        title: impl Into<String>,
        severity: IssueSeverity,
        location: impl Into<String>,
        description: impl Into<String>,
        suggestion: impl Into<String>,
    ) -> Self {
        Self {
            title: title.into(),
            severity,
            location: location.into(),
            description: description.into(),
            suggestion: suggestion.into(),
            line_number: None,
        }
    }
}

/// Challenge report generated by Codex
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Challenge {
    /// Change ID that was challenged
    pub change_id: String,

    /// When the challenge was generated
    pub generated_at: String,

    /// Issues found, sorted by severity
    pub issues: Vec<ChallengeIssue>,

    /// Validations that passed
    pub validations_passed: Vec<String>,

    /// General recommendations
    pub recommendations: Vec<String>,

    /// Impact assessment
    pub impact: ChallengeImpact,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChallengeImpact {
    /// Files that need to be modified
    pub files_to_modify: Vec<PathBuf>,

    /// New files that will be created
    pub new_files: Vec<PathBuf>,

    /// Tests that need updates
    pub tests_to_update: Vec<PathBuf>,

    /// Overall risk level
    pub risk_level: String,
}

impl Challenge {
    pub fn new(change_id: impl Into<String>) -> Self {
        Self {
            change_id: change_id.into(),
            generated_at: chrono::Local::now().to_rfc3339(),
            issues: Vec::new(),
            validations_passed: Vec::new(),
            recommendations: Vec::new(),
            impact: ChallengeImpact {
                files_to_modify: Vec::new(),
                new_files: Vec::new(),
                tests_to_update: Vec::new(),
                risk_level: "Unknown".to_string(),
            },
        }
    }

    /// Count issues by severity
    pub fn count_by_severity(&self) -> (usize, usize, usize) {
        let high = self.issues.iter().filter(|i| i.severity == IssueSeverity::High).count();
        let medium = self.issues.iter().filter(|i| i.severity == IssueSeverity::Medium).count();
        let low = self.issues.iter().filter(|i| i.severity == IssueSeverity::Low).count();
        (high, medium, low)
    }

    /// Check if there are critical issues (High severity)
    pub fn has_critical_issues(&self) -> bool {
        self.issues.iter().any(|i| i.severity == IssueSeverity::High)
    }
}
