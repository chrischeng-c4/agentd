use serde::{Deserialize, Serialize};

/// Status of a test
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum TestStatus {
    Pass,
    Fail,
    Skip,
    Pending,
}

impl TestStatus {
    pub fn emoji(&self) -> &'static str {
        match self {
            TestStatus::Pass => "âœ…",
            TestStatus::Fail => "âŒ",
            TestStatus::Skip => "â­ï¸",
            TestStatus::Pending => "â¸ï¸",
        }
    }

    pub fn name(&self) -> &'static str {
        match self {
            TestStatus::Pass => "PASS",
            TestStatus::Fail => "FAIL",
            TestStatus::Skip => "SKIP",
            TestStatus::Pending => "PENDING",
        }
    }
}

/// Result of running a single test
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestResult {
    /// Name of the test
    pub name: String,

    /// Test status
    pub status: TestStatus,

    /// Error message if failed
    pub error: Option<String>,

    /// Duration in milliseconds
    pub duration_ms: Option<u64>,

    /// Which requirement this test validates
    pub requirement: String,

    /// Which scenario this test validates
    pub scenario: String,
}

impl TestResult {
    pub fn new(
        name: impl Into<String>,
        status: TestStatus,
        requirement: impl Into<String>,
        scenario: impl Into<String>,
    ) -> Self {
        Self {
            name: name.into(),
            status,
            error: None,
            duration_ms: None,
            requirement: requirement.into(),
            scenario: scenario.into(),
        }
    }

    pub fn with_error(mut self, error: impl Into<String>) -> Self {
        self.error = Some(error.into());
        self
    }

    pub fn with_duration(mut self, ms: u64) -> Self {
        self.duration_ms = Some(ms);
        self
    }
}

/// Task implementation status
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum TaskStatus {
    /// Not started
    Pending,
    /// In progress
    InProgress,
    /// Completed
    Completed,
}

impl TaskStatus {
    pub fn emoji(&self) -> &'static str {
        match self {
            TaskStatus::Pending => "â¬œ",
            TaskStatus::InProgress => "ðŸ”„",
            TaskStatus::Completed => "âœ…",
        }
    }

    pub fn from_markdown(s: &str) -> Self {
        match s.trim() {
            "[ ]" => TaskStatus::Pending,
            "[>]" => TaskStatus::InProgress,
            "[x]" | "[X]" => TaskStatus::Completed,
            _ => TaskStatus::Pending,
        }
    }
}

/// Implementation task
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Task {
    /// Task ID (e.g., "1.1", "2.3")
    pub id: String,

    /// Task description
    pub description: String,

    /// Current status
    pub status: TaskStatus,
}

/// Verification report generated by Codex
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Verification {
    /// Change ID that was verified
    pub change_id: String,

    /// When verification was run
    pub verified_at: String,

    /// Test results
    pub tests: Vec<TestResult>,

    /// Task progress
    pub tasks: Vec<Task>,

    /// Issues found during verification
    pub issues: Vec<String>,

    /// Coverage statistics
    pub coverage: VerificationCoverage,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerificationCoverage {
    /// Number of requirements tested
    pub requirements_tested: usize,

    /// Total requirements
    pub requirements_total: usize,

    /// Number of scenarios tested
    pub scenarios_tested: usize,

    /// Total scenarios
    pub scenarios_total: usize,

    /// Test pass rate (0.0 - 1.0)
    pub pass_rate: f64,
}

impl Verification {
    pub fn new(change_id: impl Into<String>) -> Self {
        Self {
            change_id: change_id.into(),
            verified_at: chrono::Local::now().to_rfc3339(),
            tests: Vec::new(),
            tasks: Vec::new(),
            issues: Vec::new(),
            coverage: VerificationCoverage {
                requirements_tested: 0,
                requirements_total: 0,
                scenarios_tested: 0,
                scenarios_total: 0,
                pass_rate: 0.0,
            },
        }
    }

    /// Calculate overall pass rate
    pub fn pass_rate(&self) -> f64 {
        if self.tests.is_empty() {
            return 0.0;
        }
        let passed = self.tests.iter().filter(|t| t.status == TestStatus::Pass).count();
        passed as f64 / self.tests.len() as f64
    }

    /// Check if all tests passed
    pub fn all_passed(&self) -> bool {
        self.tests.iter().all(|t| t.status == TestStatus::Pass)
    }

    /// Get completion percentage (0-100)
    pub fn completion_percentage(&self) -> u8 {
        if self.tasks.is_empty() {
            return 0;
        }
        let completed = self.tasks.iter().filter(|t| t.status == TaskStatus::Completed).count();
        ((completed as f64 / self.tasks.len() as f64) * 100.0) as u8
    }
}
