use crate::context::resolve_change_id_conflict;
use crate::fillback::StrategyFactory;
use crate::Result;
use colored::Colorize;
use std::env;
use std::path::PathBuf;

/// Run the fillback command to bootstrap Agentd specs
///
/// # Workflow
/// 1. Resolve change-id conflicts (prompt user if needed)
/// 2. Parse arguments and select strategy (auto-detect if needed)
/// 3. Execute the strategy to import/generate specs
/// 4. Ensure proposal.md and tasks.md exist (create skeletons if missing)
pub async fn run(
    change_id: &str,
    path: Option<&str>,
    strategy: Option<&str>,
) -> Result<()> {
    let project_root = env::current_dir()?;
    let changes_dir = project_root.join("agentd/changes");

    // Ensure changes directory exists
    std::fs::create_dir_all(&changes_dir)?;

    println!("{}", "ðŸ”„ Agentd Fillback".cyan().bold());
    println!(
        "{}",
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”".bright_black()
    );
    println!();

    // Step 1: Resolve change-id conflicts
    let resolved_change_id = resolve_change_id_conflict(change_id, &changes_dir)?;

    // Step 2: Determine source path
    let source_path = if let Some(p) = path {
        PathBuf::from(p)
    } else {
        // Default to current directory
        project_root.clone()
    };

    // Validate source path exists
    if !source_path.exists() {
        anyhow::bail!("Source path does not exist: {}", source_path.display());
    }

    println!(
        "{}",
        format!("ðŸ“‚ Source: {}", source_path.display()).bright_black()
    );

    // Step 3: Select strategy
    let strategy_type = strategy.unwrap_or("auto");
    println!(
        "{}",
        format!("ðŸŽ¯ Strategy: {}", strategy_type).bright_black()
    );
    println!();

    let import_strategy = StrategyFactory::create(strategy_type, &source_path)?;

    // Step 4: Execute the strategy
    println!(
        "{}",
        format!("ðŸš€ Executing {} strategy...", import_strategy.name()).cyan()
    );
    println!();

    import_strategy
        .execute(&source_path, &resolved_change_id)
        .await?;

    // Step 5: Ensure proposal.md and tasks.md exist
    let change_dir = changes_dir.join(&resolved_change_id);
    ensure_required_files(&change_dir, &resolved_change_id)?;

    println!();
    println!("{}", "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”".bright_black());
    println!("{}", "âœ… Fillback completed successfully!".green().bold());
    println!();
    println!(
        "{}",
        format!("ðŸ“ Change directory: agentd/changes/{}", resolved_change_id).cyan()
    );
    println!();
    println!("{}", "Next steps:".bright_black());
    println!("  1. Review generated files in agentd/changes/{}/", resolved_change_id);
    println!("  2. Edit proposal.md and specs/*.md as needed");
    println!("  3. Run: agentd challenge {}", resolved_change_id);

    Ok(())
}

/// Ensure required files exist in the change directory
///
/// Creates skeleton files if they don't exist after strategy execution
fn ensure_required_files(change_dir: &PathBuf, change_id: &str) -> Result<()> {
    // Ensure proposal.md exists
    if !change_dir.join("proposal.md").exists() {
        let proposal_content = format!(
            "# Change: {}\n\n\
             ## Summary\n\
             (Generated by fillback - please fill in)\n\n\
             ## Why\n\
             (Please describe the motivation for this change)\n\n\
             ## What Changes\n\
             (Please describe what will change)\n\n\
             ## Impact\n\
             - **Affected Specs:** (To be determined)\n\
             - **Affected Code:** (To be determined)\n\
             - **Breaking Changes:** (To be determined)\n",
            change_id
        );
        std::fs::write(change_dir.join("proposal.md"), proposal_content)?;
    }

    // Ensure tasks.md exists
    if !change_dir.join("tasks.md").exists() {
        let tasks_content = "# Tasks\n\n\
            ## 1. Review\n\
            - [ ] 1.1 Review generated specifications\n\
              - File: agentd/changes/*/specs/*.md\n\
              - Do: Review and validate the imported/generated specifications.\n\n\
            ## 2. Implementation\n\
            - [ ] 2.1 Implement changes based on specifications\n\
              - File: (To be determined)\n\
              - Do: Implement the required changes based on the specifications.\n";
        std::fs::write(change_dir.join("tasks.md"), tasks_content)?;
    }

    // Ensure specs directory exists
    let specs_dir = change_dir.join("specs");
    if !specs_dir.exists() {
        std::fs::create_dir_all(&specs_dir)?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_ensure_required_files() {
        let temp_dir = TempDir::new().unwrap();
        let change_dir = temp_dir.path().join("test-change");
        fs::create_dir(&change_dir).unwrap();

        ensure_required_files(&change_dir, "test-change").unwrap();

        assert!(change_dir.join("proposal.md").exists());
        assert!(change_dir.join("tasks.md").exists());
        assert!(change_dir.join("specs").exists());
    }

    #[test]
    fn test_ensure_required_files_preserves_existing() {
        let temp_dir = TempDir::new().unwrap();
        let change_dir = temp_dir.path().join("test-change");
        fs::create_dir(&change_dir).unwrap();

        // Create existing files
        let existing_proposal = "# Existing Proposal\n\nDo not overwrite";
        fs::write(change_dir.join("proposal.md"), existing_proposal).unwrap();

        ensure_required_files(&change_dir, "test-change").unwrap();

        // Should not overwrite existing file
        let content = fs::read_to_string(change_dir.join("proposal.md")).unwrap();
        assert_eq!(content, existing_proposal);

        // Should still create missing files
        assert!(change_dir.join("tasks.md").exists());
    }
}
